#!/usr/bin/env bash
#
# usage: ./run command [argument ...]
#
# Commands for halos-marine-containers development.
#
# See https://death.andgravity.com/run-sh
# for an explanation of how it works and why it's useful.

# First, set up the environment.
# (Check the notes at the end when changing this.)

set -o nounset
set -o pipefail
set -o errexit

# Enable this to echo commands as they are executed.
#set -o xtrace

# Change the current directory to the project root.
PROJECT_ROOT=${0%/*}
if [[ $0 != $PROJECT_ROOT && $PROJECT_ROOT != "" ]]; then
  cd "$PROJECT_ROOT"
fi
readonly PROJECT_ROOT=$(pwd)

# Store the absolute path to this script (useful for recursion).
readonly SCRIPT="$PROJECT_ROOT/$(basename "$0")"

################################################################################
# Lint Commands

function lint {
  #@ Validate all docker-compose files
  #@ Category: Lint
  echo "üîç Validating docker-compose files..."
  local failed=0
  local checked=0

  for compose_file in apps/*/docker-compose.yml; do
    if [ -f "$compose_file" ]; then
      checked=$((checked + 1))
      local app_name=$(dirname "$compose_file" | xargs basename)
      if docker compose -f "$compose_file" config > /dev/null 2>&1; then
        echo "  ‚úÖ $app_name"
      else
        echo "  ‚ùå $app_name"
        docker compose -f "$compose_file" config 2>&1 | sed 's/^/     /'
        failed=$((failed + 1))
      fi
    fi
  done

  echo ""
  if [ $failed -eq 0 ]; then
    echo "‚úÖ All $checked compose files are valid"
  else
    echo "‚ùå $failed of $checked compose files have errors"
    return 1
  fi
}

function lint:verbose {
  #@ Validate and show parsed docker-compose files
  #@ Category: Lint
  echo "üîç Validating docker-compose files (verbose)..."

  for compose_file in apps/*/docker-compose.yml; do
    if [ -f "$compose_file" ]; then
      local app_name=$(dirname "$compose_file" | xargs basename)
      echo ""
      echo "‚îÅ‚îÅ‚îÅ $app_name ‚îÅ‚îÅ‚îÅ"
      docker compose -f "$compose_file" config
    fi
  done
}

################################################################################
# Test Commands

function test {
  #@ Run test suite in Docker container
  #@ Category: Testing
  echo "üß™ Running tests..."
  docker run --rm -v "$(pwd):/workspace" -w /workspace python:3.11-slim \
    bash -c "pip install -q pytest pyyaml && python -m pytest tests/ -v"
}

function test:watch {
  #@ Run tests in watch mode (requires pytest-watch locally)
  #@ Category: Testing
  echo "üëÄ Watching tests..."
  if ! command -v ptw &> /dev/null; then
    echo "‚ùå pytest-watch not found. Install with: pip install pytest-watch"
    return 1
  fi
  ptw tests/
}

################################################################################
# Version Management Commands

function bump-version {
  #@ Bump release bundle version (VERSION file)
  #@ Category: Version
  local bump_type="$1"

  if [[ ! "$bump_type" =~ ^(patch|minor|major)$ ]]; then
    echo "Usage: ./run bump-version [patch|minor|major]"
    echo ""
    echo "Bumps the release bundle version in VERSION file."
    echo "Use this when any package update warrants a new release."
    return 1
  fi

  if ! command -v bumpversion &> /dev/null; then
    echo "‚ùå bumpversion not found. Install with:"
    echo "   pip install bumpversion"
    return 1
  fi

  echo "üì¶ Bumping release bundle version ($bump_type)..."
  bumpversion "$bump_type"
  local new_version=$(cat VERSION)
  echo "‚úÖ Release bundle version bumped to $new_version"
}

function bump-store {
  #@ Bump store package version (store/debian/changelog)
  #@ Category: Version
  local bump_type="$1"

  if [[ ! "$bump_type" =~ ^(patch|minor|major)$ ]]; then
    echo "Usage: ./run bump-store [patch|minor|major]"
    echo ""
    echo "Bumps the store package version in store/debian/changelog."
    echo "Use this when the store definition changes."
    return 1
  fi

  # Read current version from changelog (first line, extract version between parentheses)
  local current_version=$(head -1 store/debian/changelog | sed 's/.*(\([^)]*\)).*/\1/' | cut -d- -f1)

  # Calculate new version using semver logic
  IFS='.' read -r major minor patch <<< "$current_version"
  case "$bump_type" in
    major)
      major=$((major + 1))
      minor=0
      patch=0
      ;;
    minor)
      minor=$((minor + 1))
      patch=0
      ;;
    patch)
      patch=$((patch + 1))
      ;;
  esac
  local new_version="${major}.${minor}.${patch}"

  echo "üì¶ Bumping store package version: $current_version ‚Üí $new_version..."

  # Create new changelog entry (prepend to file)
  local temp_file=$(mktemp)
  cat > "$temp_file" <<CHANGELOG
marine-container-store (${new_version}-1) stable; urgency=medium

  * Version bump to ${new_version}

 -- Hat Labs <info@hatlabs.fi>  $(date '+%a, %d %b %Y %H:%M:%S %z')

CHANGELOG
  cat store/debian/changelog >> "$temp_file"
  mv "$temp_file" store/debian/changelog

  echo "‚úÖ Store package version bumped to ${new_version}-1"
  echo ""
  echo "‚ö†Ô∏è  Don't forget to edit store/debian/changelog to add details about what changed!"
}

function list-versions {
  #@ List all current versions
  #@ Category: Version
  echo "Version Information"
  echo "==================="
  echo ""

  echo "üì¶ Release Bundle (VERSION):"
  cat VERSION
  echo ""

  echo "üì¶ Store Package (store/debian/changelog):"
  local store_version=$(head -1 store/debian/changelog | sed 's/.*(\([^)]*\)).*/\1/')
  echo "$store_version"
  echo ""

  echo "üì¶ Marine Apps:"
  for app in apps/*/; do
    local app_name=$(basename "$app")
    if [ -f "$app/metadata.yaml" ]; then
      local version=$(grep "^version:" "$app/metadata.yaml" | cut -d: -f2 | xargs)
      printf "  %-20s %s\n" "${app_name}:" "$version"
    fi
  done
}

################################################################################
# Build Commands

# Docker image name for building
readonly DOCKER_IMAGE="halos-marine-containers-builder"

function build-debtools {
  #@ Build Docker image for package building
  #@ Category: Build
  echo "Building Docker image for package building..."

  # Create docker directory if it doesn't exist
  mkdir -p docker

  # Create Dockerfile if it doesn't exist
  if [ ! -f docker/Dockerfile.debtools ]; then
    cat > docker/Dockerfile.debtools << 'DOCKERFILE'
FROM debian:trixie

RUN apt-get update && apt-get install -y \
    debhelper \
    dh-python \
    build-essential \
    fakeroot \
    devscripts \
    dpkg-dev \
    python3-all \
    python3-pip \
    python3-venv \
    pipx \
    && rm -rf /var/lib/apt/lists/*

RUN pipx install uv && pipx ensurepath

WORKDIR /workspace
DOCKERFILE
  fi

  docker build -t "$DOCKER_IMAGE" -f docker/Dockerfile.debtools docker/
}

function build {
  #@ Build all container packages (in Docker)
  #@ Category: Build
  echo "Building all container packages..."

  # Require HALOS_HOSTNAME for registry generation
  if [[ -z "${HALOS_HOSTNAME:-}" ]]; then
    echo "ERROR: HALOS_HOSTNAME environment variable is required."
    echo "Example: HALOS_HOSTNAME=halos.local ./run build"
    return 1
  fi

  # Ensure Docker image exists
  if ! docker image inspect "$DOCKER_IMAGE" &>/dev/null; then
    echo "Docker image not found. Building..."
    build-debtools
  fi

  # Run build in Docker container
  docker run --rm -v "$(pwd):/workspace" \
    -e HALOS_HOSTNAME="$HALOS_HOSTNAME" \
    -e CONTAINER_TOOLS_REF="${CONTAINER_TOOLS_REF:-}" \
    "$DOCKER_IMAGE" \
    bash -c "cd /workspace && ./tools/build-all.sh"
}

function deploy {
  #@ Deploy packages to test server (usage: ./run deploy <target> [packages])
  #@ Category: Build
  local target="${1:-}"
  local packages="${2:-all}"

  if [[ -z "$target" ]]; then
    echo "Usage: ./run deploy <target> [packages]"
    echo ""
    echo "Arguments:"
    echo "  target     Target host (e.g., pi@myhost.local)"
    echo "  packages   Package names or 'all' (default: all)"
    echo ""
    echo "Examples:"
    echo "  ./run deploy pi@myhost.local"
    echo "  ./run deploy pi@myhost.local signalk"
    return 1
  fi
  local deb_files=()

  if [ "$packages" = "all" ]; then
    # Deploy all built packages
    for deb in build/*.deb; do
      [ -f "$deb" ] && deb_files+=("$deb")
    done
  else
    # Deploy specific package(s)
    for pkg in $packages; do
      local deb_file
      deb_file=$(ls -t build/*-${pkg}-container*.deb 2>/dev/null | head -1)
      [ -n "$deb_file" ] && deb_files+=("$deb_file")
    done
  fi

  if [ ${#deb_files[@]} -eq 0 ]; then
    echo "No .deb files found. Run ./run build first."
    exit 1
  fi

  echo "Deploying ${#deb_files[@]} package(s) to $target..."
  for deb in "${deb_files[@]}"; do
    echo "  - $(basename "$deb")"
  done

  scp "${deb_files[@]}" "$target:/tmp/"

  local remote_debs=""
  for deb in "${deb_files[@]}"; do
    remote_debs="$remote_debs /tmp/$(basename "$deb")"
  done

  ssh "$target" "sudo apt install -y --allow-downgrades $remote_debs"
  echo "Deployment complete."
}

function deploy-build {
  #@ Build and deploy all packages to test server
  #@ Category: Build
  build
  deploy "$@"
}

################################################################################
# Cleanup Commands

function clean {
  #@ Clean build artifacts and cache
  #@ Category: Utility
  echo "üßπ Cleaning..."
  rm -rf build/ dist/ *.egg-info
  rm -rf .pytest_cache
  find . -type d -name __pycache__ -exec rm -rf {} + 2>/dev/null || true
  find . -type f -name "*.pyc" -delete
  echo "‚úÖ Cleaned"
}

################################################################################
# Help System

function help {
  #@ Show this help message
  #@ Category: Core
  echo "HaLOS Marine Containers - Development Commands"
  echo "=============================================="
  echo ""
  echo "Available commands:"
  echo ""

  # Extract function definitions and their help comments
  awk '/^function / {
    fname = $2
    sub(/[({].*/, "", fname)
    getline
    if ($0 ~ /#@/) {
      desc = $0
      sub(/.*#@ /, "", desc)
      sub(/ *$/, "", desc)
      getline
      if ($0 ~ /#@ Category:/) {
        cat = $0
        sub(/.*Category: /, "", cat)
        sub(/ *$/, "", cat)
        if (!seen[cat]++) categories[++cat_count] = cat
        commands[cat, ++cmd_count[cat]] = fname
        descriptions[cat, cmd_count[cat]] = desc
      }
    }
  }
  END {
    for (i = 1; i <= cat_count; i++) {
      cat = categories[i]
      print "\n" cat ":"
      for (j = 1; j <= cmd_count[cat]; j++) {
        printf "  %-30s %s\n", commands[cat, j], descriptions[cat, j]
      }
    }
  }' "$0"

  echo ""
  echo "Usage: ./run <command> [arguments...]"
}

################################################################################
# Commands end.

# Dispatch to command. A simpler version would be just "$@" (with the quotes!).

TIMEFORMAT=$'\nTask completed in %3lR'
time "${@:-help}"

# Some dev notes for this script.
#
# The commands *require*:
#
# * The current working directory is the project root.
# * The shell options and globals are set as they are.
#
# Inspired by the following:
#  - https://death.andgravity.com/run-sh
#  - http://www.oilshell.org/blog/2020/02/good-parts-sketch.html
#  - https://www.youtube.com/watch?v=SdmYd5hJISM&t=7s
